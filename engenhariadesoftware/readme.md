Primeiro trecho do livro Software Engineering at Google, Oreilly: A principal diferença entre o ato de "programar" e a engenharia de software em si, é que a segunda utiliza de conhecimentos teóricos e práticas mais sérias para a construção de programas, mesmo que sejam diretrizes menos rigorosas comparadas a outras engenharias. O ponto que mais chama a atenção na engenharia de software é que o seu objeto de estudo é menos tangível que o que as outras engenharias criam e, além disso, o fato de ser uma área do conhecimento muito nova de apenas 56 anos (comparado com os mais de 4.500 anos da engenharia civil).

Segundo Trecho do livro Software Engeneering at Google, Oreilly: Engenharia de software não é só programar, mas manter código adaptável ao longo do tempo.
Baseia-se em três princípios:

*Tempo e Mudança* – o código precisa se adaptar durante todo o seu ciclo de vida.
*Escala e Crescimento* – a organização deve evoluir conforme aumenta em tamanho e complexidade.
*Trade-offs e Custos* – as decisões devem equilibrar mudanças, crescimento e os recursos disponíveis.

O objetivo é garantir valor, adaptação e rigor na evolução do software.
3 exemplos de trade-offs que impactam a engenharia de software: 

Velocidade de entrega × Qualidade do código

Entregar rápido pode significar código com menos testes ou soluções “quebra-galho”. Isso acelera o resultado imediato, mas pode gerar dívida técnica no futuro. O contrário (foco extremo em qualidade) atrasa a entrega inicial.

Performance × Manutenibilidade

Código altamente otimizado tende a ser mais complexo e difícil de entender, o que dificulta a manutenção. Já um código mais simples e legível pode ser menos eficiente em desempenho, mas facilita futuras alterações.

Customização × Padronização

Permitir muitas opções e flexibilidade no sistema pode atender melhor a diferentes necessidades, mas aumenta a complexidade de manutenção. Padronizar reduz custos e erros, mas pode limitar as possibilidades do usuário ou da equipe.

